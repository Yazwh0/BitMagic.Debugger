.machine CommanderX16R42
; DDRA is data direction.
; PRA is the data

.const SDA = 1
.const SCL = 2
.const SMC = $42

	sei

	ldx #SMC
	ldy #$07 ; keyboard

	jsr i2c_read_first_byte
	jsr i2c_read_next_byte
	jsr i2c_read_stop


	jsr i2c_read_byte
	stp

	;jsr write_first_byte
	jsr i2c_read_first_byte
	jsr i2c_read_stop

	ldx #SMC
	ldy #$07 ; keyboard

;	jsr i2c_read_next_byte
	jsr i2c_read_first_byte
	jsr i2c_read_stop
	
    stp

;---------------------------------------------------------------
; i2c_write_first_byte
; 
; Function: Writes one byte over I2C without stopping the
;           transmission. Subsequent bytes may be wri%tten by
;           i2c_write_next_byte. When done, call function
;           i2c_write_stop to close the I2C transmission.
;
; Pass:      a    value
;            x    7-bit device address
;            y    offset
;
; Return:    c    1 on error (NAK)
;---------------------------------------------------------------
.proc write_first_byte
	pha                ; value
	jsr i2c_init
	jsr i2c_start
	txa                ; device
	asl
	phy
	jsr i2c_write
	ply
	bcs error
	tya                ; offset
	phy
	jsr i2c_write
	ply
	pla                ; value
	jsr i2c_write
	clc
	rts

.error:
	pla                ; value
	sec
	rts
.endproc

;---------------------------------------------------------------
; i2c_write_next_byte
;
; Function:	After the first byte has been written by 
;			i2c_write_first_byte, this function may be used to
;			write one or more subsequent bytes without 
;			restarting the I2C transmission
;
; Pass:		a    value
;
; Return:	Nothing
;---------------------------------------------------------------
.proc i2c_write_next_byte
	jmp i2c_write
.endproc

;---------------------------------------------------------------
; i2c_write
;
; Function: Write a single byte over I2C
;
; Pass:      a    byte to write
;
; Return:    c    0 if ACK, 1 if NAK
;
; I2C Exit:  SDA: Z
;            SCL: 0
;---------------------------------------------------------------
.proc i2c_write
	ldx #8
.i2c_write_loop:
	rol
	tay
	jsr send_bit
	tya
	dex
	bne i2c_write_loop
	jsr rec_bit     ; C = 0: success
	rts
.endproc

;---------------------------------------------------------------
; i2c_write_stop
;
; Function:	Stops I2C transmission that has been initialized
;			with i2c_write_first_byte
;
; Pass:		Nothing
;
; Return:	Nothing
;---------------------------------------------------------------
.proc i2c_write_stop
	jsr i2c_stop
.endproc


;---------------------------------------------------------------
; i2c_read_byte
;
; Function:
;
; Read sequence:
;   Start condition
;     > 7 bits of device address, MSb first
;     > 1 bit = 0 (write indicator bit)
;     < Read ACK/NAK from device
;     > 8 bits of register offset
;   Stop condition
;   Start condition
;     > 7 bits of device address, MSb first
;     > 1 bit = 1 (read indicator bit)
;     < Read ACK/NAK from device (this is not done by the kernel!!)
;     < Read 8 bits from device
;     > NAK to indicate end of requested bytes from device
;   Stop condition
;
; Pass:      x    7-bit device address
;            y    offset
;
; Return:    a    value
;            x    device (preserved)
;            y    offset (preserved)
;            c    1 on error (NAK)
;---------------------------------------------------------------
.proc i2c_read_byte
	php
	sei
	phx
	phy

	jsr i2c_read_first_byte
	bcs err
	pha
	jsr i2c_read_stop
	pla
	
	ply
	plx
	plp
	
	cmp #0
	clc
	
	rts

.err:
	ply
	plx
	plp
	sec
	lda #$ee
	rts
.endproc

;---------------------------------------------------------------
; i2c_read_first_byte
;
; Function: Reads one byte over I2C without stopping the
;           transmission. Subsequent bytes may be read by
;           i2c_read_next_byte. When done, call function
;           i2c_read_stop to close the I2C transmission.
;
; Pass:      x    7-bit device address
;            y    offset
;
; Return:    a    value
;            c    1 on error (NAK)
;---------------------------------------------------------------
.proc i2c_read_first_byte
	jsr i2c_init
	jsr i2c_start                        ; SDA -> LOW, (wait 5 us), SCL -> LOW, (no wait)
	txa                ; device
	asl
	pha                ; device * 2
	phy
	jsr i2c_write
	ply
	bcs error
	plx                ; device * 2
	tya                ; offset
	phx                ; device * 2
	jsr i2c_write
	jsr i2c_stop
	jsr i2c_start ; doesn't appear to start the i2c protocol
	pla                ; device * 2
	inc                ; Flag data is from the SMC
	jsr i2c_write		
	bra i2c_read_next_byte_after_ack
	
.error:
	pla
	jsr i2c_stop
	lda #$ee
	sec
	rts
.endproc

;---------------------------------------------------------------
; i2c_read_next_byte
;
; Function:	After the first byte has been read by 
;			i2c_read_first_byte, this function may be used to
;			read one or more subsequent bytes without 
;			restarting the I2C transmission
;
; Pass:		Nothing
;
; Return:	a    value
;---------------------------------------------------------------
.proc i2c_read_next_byte
	jsr i2c_ack
	jsr i2c_read_next_byte_after_ack
	rts
.endproc

;---------------------------------------------------------------
; i2c_read_stop
;
; Function:	Stops I2C transmission that has been initialized
;			with i2c_read_first_byte
;
; Pass:		Nothing
;
; Return:	Nothing
;---------------------------------------------------------------
.proc i2c_read_stop
	jsr i2c_nack
	jsr i2c_stop
	rts
.endproc

.proc i2c_ack
	clc
	jsr send_bit
	rts
.endproc

.proc i2c_nack
	sec
	jsr send_bit
	rts
.endproc

.proc i2c_read_next_byte_after_ack
	jsr i2c_read
	cmp #0
	clc
	rts
.endproc 

.proc i2c_read
	ldx #8
.i2c_read_loop:
	tay
	jsr rec_bit
	tya
	rol
	dex
	bne i2c_read_loop
	rts
.endproc 

.proc i2c_start
	jsr sda_low
	jsr i2c_brief_delay
	jsr scl_low
	rts
.endproc

.proc i2c_stop
	jsr sda_low
	jsr i2c_brief_delay
	jsr scl_high
	jsr i2c_brief_delay
	jsr sda_high
	jsr i2c_brief_delay
	rts
.endproc

.proc sda_low
	lda #SDA
	tsb V_DDRA
	rts
.endproc

.proc sda_high
	lda #SDA
	trb V_DDRA
    rts
.endproc

.proc scl_low
	lda #SCL
	tsb V_DDRA
	rts
.endproc

.proc scl_high
	lda #SCL
	trb V_DDRA
.loop:
	lda V_PRA     ; Wait for clock to go high
	and #SCL
	beq loop
	rts
.endproc

.proc send_bit
	bcs high
	jsr sda_low
	bra done
.high:
	jsr sda_high
.done:
    jsr scl_high
	jsr scl_low
    rts
.endproc

.proc i2c_init
	lda #SDA | SCL
	trb V_PRA
	jsr sda_high
	jsr scl_high
	rts
.endproc

.proc rec_bit
	jsr sda_high		; Release SDA so that device can drive it
	jsr scl_high
	lda V_PRA
	lsr             ; bit -> C
	jsr scl_low
	rts
.endproc

.proc i2c_brief_delay
    nop
    nop
    nop
    nop
    rts
.endproc