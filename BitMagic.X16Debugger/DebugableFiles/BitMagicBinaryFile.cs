using BitMagic.Common;
using BitMagic.Common.Address;
using BitMagic.Compiler;
using BitMagic.X16Debugger.Extensions;
using BitMagic.X16Emulator;
using Microsoft.CodeAnalysis;
using Silk.NET.Core.Native;

namespace BitMagic.X16Debugger.DebugableFiles;

/// <summary>
/// Binary file that has been generated by the compiler.
/// Includes debugging extensions
/// </summary>
internal class BitMagicBinaryFile : SourceFileBase, IBinaryFile
{
    public IReadOnlyList<byte> Data { get; }
    public int BaseAddress { get; private set; }

    private readonly Dictionary<int, string> _symbols = new Dictionary<int, string>();
    public IReadOnlyDictionary<int, string> Symbols => _symbols;

    public override IReadOnlyList<string> Content { get; protected set; } = Array.Empty<string>();

    private readonly List<ISourceFile> _parents = new List<ISourceFile>();
    public override IReadOnlyList<ISourceFile> Parents => _parents;
    private readonly ParentSourceMapReference[] _parentMap;
    public override IReadOnlyList<ParentSourceMapReference> ParentMap => _parentMap;

    private CompileResult _result;

    internal BitMagicBinaryFile(SourceFileBase source, NamedStream stream, CompileResult result)
    {
        Origin = SourceFileType.Binary;
        ActualFile = false; // this is for source files?
        Name = System.IO.Path.GetFileName(stream.FileName).ToUpper();
        Path = stream.FileName.ToUpper();
        Data = stream.ToArray();
        _parents.Add(source);
        _parentMap = new ParentSourceMapReference[Data.Count];
        _result = result;
        for (var i = 0; i < _parentMap.Length; i++)
        {
            _parentMap[i] = new ParentSourceMapReference(-1, -1);
        }

        source.AddChild(this);
        CreateChildMap();
    }

    private void CreateChildMap()
    {
        var state = _result.State;

        var segment = state.Segments.Values.FirstOrDefault(i => string.Equals(i.Filename, Name, StringComparison.InvariantCultureIgnoreCase));

        if (segment != null) // error condition?
        {
            BaseAddress = segment.StartAddress;

            foreach (var defaultProc in segment.DefaultProcedure.Values)
            {
                MapProcForParents(defaultProc);
            }
        }

        foreach (var (name, value) in _result.State.ScopeFactory.GlobalVariables.GetChildVariables("App"))
        {
            if (!Symbols.ContainsKey(value))
                _symbols.Add(value, name);
        }
    }

    /// <summary>
    /// Map a procedure to the memory location.
    /// ParentMap is an array of the length of the binary file.
    /// </summary>
    /// <param name="proc"></param>
    private void MapProcForParents(Procedure proc)
    {
        foreach (var line in proc.Data)
        {
            // all lines go to the parent, as thats the generated code
            _parentMap[line.Address - BaseAddress] = new ParentSourceMapReference(line.Source.LineNumber - 1, 0); // this is zero based
        }

        foreach (var p in proc.Procedures)
            MapProcForParents(p);
    }


    /// <summary>
    /// Map the file to the source map for the stack, called in the binary file load in the DebugWrapper.
    /// </summary>
    /// <param name="emulator"></param>
    internal void MapProcToMemory(Emulator emulator, SourceMapManager sourceMapManager)
    {
        var state = _result.State;

        var segment = state.Segments.Values.FirstOrDefault(i => string.Equals(i.Filename, Name, StringComparison.InvariantCultureIgnoreCase));

        if (segment != null) // error condition?
        {
            foreach (var defaultProc in segment.DefaultProcedure.Values)
            {
                MapProcToMemory(defaultProc, emulator, sourceMapManager);
            }
        }

    }

    private void MapProcToMemory(Procedure proc, Emulator emulator, SourceMapManager sourceMapManager)
    {
        foreach (var line in proc.Data)
        {
            // need to store the memory to line in the file lookup, which is used by the stack code
            var toAdd = new SourceMapLine(line, proc);

            var debuggerAddress = AddressFunctions.GetDebuggerAddress(toAdd.Address, emulator);

            sourceMapManager.AddSourceMap(debuggerAddress, toAdd);
        }

        foreach (var p in proc.Procedures)
            MapProcToMemory(p, emulator, sourceMapManager);
    }

    public override Task UpdateContent() => Task.CompletedTask;

    public void LoadIntoMemory(Emulator emulator, int address) => emulator.LoadIntoMemory(Data.ToArray(), address);
}

internal static class CompileResultExtensions
{
    internal static IList<BitMagicBinaryFile> CreateBinarySourceFiles(this CompileResult result)
    {
        var toReturn = new List<BitMagicBinaryFile>();

        // go through each output and create file on each
        foreach (var i in result.Data.Where(i => i.Value.Length != 0)) // dont process segment that do not have data
        {
            toReturn.Add(new BitMagicBinaryFile(result.Project.Code, i.Value, result));
        }

        return toReturn;
    }
}